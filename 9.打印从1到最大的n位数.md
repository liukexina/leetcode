# 打印从1到最大的n位数

## 题目
输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

示例：
```
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```

## 解答

### 不考虑大数
```js
var printNumbers = function(n) {
let str = '';
    const arr = [];
    for(let i = 1 ; i <= Math.pow(10, n) - 1 ; i++) {
      arr.push(i)
    }
    return arr
};
```

最大的 n 位数（记为 end ）和位数 n 的关系：

例如最大的 1 位数是 9 ，最大的 2 位数是 99 ，最大的 3 位数是 999 。则可推出公式：
```js
end = 10^n - 1
```

### 考虑大数
```js
function printNumbers(n) {
  let res = [];
  let nine = 0;
  let start = n - 1;
  dfs(0, "");
  return res;

  function dfs(x, num) {
    if (x == n) {
      let s = num.substring(start);
      if (s !== "0") res.push(parseInt(s));
      if (n - start == nine) start--;
      return;
    }
    for (let i = 0; i < 10; i++) {
      if (i === 9) nine++;
      dfs(x + 1, num + i);
    }
    nine--;
  }
}
```

大数越界问题： 当 n 较大时，end 会超出 int32 整型的取值范围，超出取值范围的数字无法正常存储。

1. 表示大数的变量类型：
无论是 short / int / long ... 任意变量类型，数字的取值范围都是有限的。因此，大数的表示应用字符串 String 类型。
2. 生成数字的字符串集：
使用 int 类型时，每轮可通过 +1 生成下个数字，而此方法无法应用至 String 类型。并且， String 类型的数字的进位操作效率较低，例如 "9999" 至 "10000" 需要从个位到千位循环判断，进位 4 次。

观察可知，生成的列表实际上是 n 位 0 - 9 的 全排列 ，因此可避开进位操作，通过递归生成数字的 String 列表。

3. 递归生成全排列：
基于分治算法的思想，先固定高位，向低位递归，当个位已被固定时，添加数字的字符串。例如当 n = 2 时（数字范围 1 - 99 ），固定十位为 0 - 9 ，按顺序依次开启递归，固定个位 0 - 9 ，终止递归并添加数字字符串。

观察可知，当前的生成方法仍有以下问题：

诸如 00, 01, 02, ⋯ 应显示为 0, 1, 2, ⋯ ，即应 删除高位多余的 0 ;
此方法从 0 开始生成，而题目要求 列表从 1 开始 ；


以上两个问题的解决方法如下：

1. 删除高位多余的 0 ：
字符串左边界定义： 声明变量 start 规定字符串的左边界，以保证添加的数字字符串 num[start:] 中无高位多余的 0 。例如当 n = 2 时， 1 - 9 时 start = 1 ， 10 - 99 时 start = 0 。

左边界 start 变化规律： 观察可知，当输出数字的所有位都是 9 时，则下个数字需要向更高位进 1 ，此时左边界 start 需要减 1 （即高位多余的 0 减少一个）。例如当 n = 3 （数字范围 1 - 999）时，左边界 start 需要减 1 的情况有： "009" 进位至 "010" ， "099" 进位至 "100" 。设数字各位中 9 的数量为 nine ，所有位都为 9 的判断条件可用以下公式表示：
```js
n - start = nine
```

统计 nine 的方法： 固定第 x 位时，当 i = 9 则执行 nine = nine + 1 ，并在回溯前恢复 nine = nine - 1 。

2. 列表从 1 开始：
在以上方法的基础上，添加数字字符串前判断其是否为 "0" ，若为 "0" 则直接跳过。
